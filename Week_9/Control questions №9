1. Используются разделяемая память (shared_memory) и файлы, записываемые в память (file_mapping)

2. File_mapping содержит в себе синхронизацию за счет ОС, чего не в shared_memory. То есть последний работает быстрее

3. Во-первых, нужно не забыть, что контейнер находится не в библиотеке std (например boost::interprocess::vector < int, allocator> вместо std::vector<int>).
Во-вторых, при поиске и создании контейнера не забыть второй аргумент с использованием метода .get_segment_manager()

4. Анонимные mutex и condition_variableсодержатся и используются в shared_memory, в то время как именованные управляются ОС

5.

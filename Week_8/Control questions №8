1.Состояние гонки - конкуренция потоков за то, чтобы выполнить действия над общими данными первыми. Она опаснее всего в случае,
когда к данным обращаются модифицирующие и читающие потоки. Тогда потоки для чтения могут обратиться к некорректным данным

2.std::mutex может быть захвачен в потоке (std::unique_lock, std::lock_guard, std::lock()). Таким образом другие потоки не смогут обращаться к тем же данным,
пока первый поток не освободит mutex.
std::condition_variable принимает какой-то мютексоподобный объект и предикат, который должна проверять

3.Если выбрать крупную грануляцию, плюсы от парраллелизма пропадут из-за глобальной блокировки.
Если выбрать мелкую грануляция, то возможна взаимоблокировка - ситуация, когда потоки ждут друг друга

4.deadlock может возникнуть в случае, когда при мелкой грануляции используются несколько мютексов для блокировки всех данных.
Чтобы предотвратить ее, можно использовать: одинаковый порядок расставления std::mutex
                                            гарантировать, чтобы один поток владел не более, чем один std::mutex
                                            использовать иерархию для std::mutex
                                            использовать std::lock()
5.Атомарными операциями называются неделимые, то есть такие операции, которые не могут быть быть выполнены наполовину.
Атомарные типы данных - такие типы данных, что любые операции над ними атомарны(например atomic_int или по-другому std::atomic<int>)
